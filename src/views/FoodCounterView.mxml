<?xml version="1.0" encoding="utf-8"?>
<!--
Copyright (C) 2013  hippoandfriends

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/gpl.txt>.

-->
<s:View xmlns:fx="http://ns.adobe.com/mxml/2009"
		xmlns:s="library://ns.adobe.com/flex/spark"
		xmlns:mx="library://ns.adobe.com/flex/mx"
		xmlns:myComponents="myComponents.*"
		actionBarVisible="true" 
		initialize="init()" 
		add="addHandler()"
		creationComplete="onCreationComplete()" xmlns:analytics="com.google.analytics.*">
	
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	
	<fx:Metadata>
		[ResourceBundle("foodcounterview")]
		[ResourceBundle("analytics")]
	</fx:Metadata>
	
	<fx:Script>
		<![CDATA[
			import databaseclasses.Database;
			import databaseclasses.DatabaseEvent;
			import databaseclasses.FoodItem;
			import databaseclasses.Settings;
			import databaseclasses.UnitChangedEvent;
			
			import flash.utils.getTimer;
			
			import model.ModelLocator;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.core.FlexGlobals;
			import mx.managers.PopUpManager;
			import mx.resources.ResourceBundle;
			
			import myComponents.AlertPopUp;
			import myComponents.HelpCallOut;
			import myComponents.Notification;
			import myComponents.PickerEvent;
			import myComponents.elementFromListPicker;
			
			import spark.events.IndexChangeEvent;
			import spark.events.PopUpEvent;
			import spark.events.ViewNavigatorEvent;
			import spark.skins.spark.DefaultItemRenderer;
			
			import utilities.ExcelSorting;
			import utilities.MyGATracker;
			import utilities.Synchronize;
			
			private static var excelSorting:ExcelSorting;
			
			private var notificationPopUp:Notification;
			
			private var elementPicker:elementFromListPicker;
			
			private var timer:Timer;
			private var licensePopUp:AlertPopUp;
			private var thisView:View;
			private var firstStartUp:Boolean = false;
			
			private var helpCallOut:HelpCallOut;
			
			[Bindable]
			/**
			 * equal to searchtext.text 
			 */
			private static var searchTextCopy:String = "";
			
			/**
			 * false is no search is done yet. Search button should be enabled, cancel button should be disabled<br>
			 * true means a search text has already been entered by the user and a search on it has been done. Search button should be disabled, cancel button enabled<br> 
			 */
			[Bindable]
			private static var searchActive:Boolean;
			
			private function init():void {
				/* add event listener for clicking item */
				fooditemlist.addEventListener(Event.CHANGE,selectFoodItem);
			}
			
			private function onCreationComplete():void {
				MyGATracker.getInstance(this);//just to make sure mygatracker is initialized with a displayobject

				Database.getInstance().addEventListener(Database.NEW_FOOD_DATABASE_STORED_SUCCESS,initiateRetrievalOfFoodItemList);
				
				thisView = this;
				
				if (!ModelLocator.getInstance().firstStartUp)  {
					Synchronize.getInstance().startSynchronize(false,false);
					ensureIndexIsVisible();
					showSearchTextBoxHelpText();
					return;
				}
				ModelLocator.getInstance().firstStartUp = false;
				
				var dispatcher:EventDispatcher = new EventDispatcher();
				var thisObject:DisplayObject =  this;
				if (Database.databaseExists()) {
					onReturn();
				} else {
					firstStartUp = true;
					notificationPopUp = new Notification();
					notificationPopUp.notificationText = resourceManager.getString('helpdiabetes','infoaboutlanguageselection');
					notificationPopUp.addEventListener(PickerEvent.PICKER_SET, okClicked);
					PopUpManager.addPopUp(notificationPopUp, thisObject, true);
					PopUpManager.centerPopUp(notificationPopUp);
				}
				
				function okClicked(event: PickerEvent):void {
					if (notificationPopUp != null) {
						PopUpManager.removePopUp(notificationPopUp);
						if (notificationPopUp.hasEventListener(PickerEvent.PICKER_SET)) {
							notificationPopUp.removeEventListener(PickerEvent.PICKER_SET, okClicked);
						}
					}
					elementPicker = new elementFromListPicker();
					elementPicker.elements = new ArrayCollection([
						resourceManager.getString('general','english'),
						resourceManager.getString('general','dutch'),
						resourceManager.getString('general','french')]);
					elementPicker.addEventListener(UnitChangedEvent.ITEM_SELECTED, onReturn);
					elementPicker.addEventListener(Event.REMOVED_FROM_STAGE,onReturn);
					elementPicker.labelText1 = resourceManager.getString('general','choose_language');
					
					PopUpManager.addPopUp(elementPicker,thisObject,true);
					PopUpManager.centerPopUp(elementPicker);
				}
				
				function onReturn(event: Event = null): void
				{
					if (elementPicker != null) {
						if (elementPicker.hasEventListener(UnitChangedEvent.ITEM_SELECTED)) {
							elementPicker.removeEventListener(UnitChangedEvent.ITEM_SELECTED, onReturn);
							elementPicker.removeEventListener(Event.REMOVED_FROM_STAGE,onReturn);
						}
						PopUpManager.removePopUp(elementPicker);
					}
					
					//we initialize first the localechain in the settngs to the current localechain
					var localeChainAsString:String;
					for (var i:int = 0;i <resourceManager.localeChain.length;i++) {
						localeChainAsString += resourceManager.localeChain[i];
					}
					
					//if event is a unitchangedevent, it means we got here after user clicked a language, so we'll change now the settings
					//if event is not a unitchaged event, it means this application doesn't start first the first itme, so a database already existed and user didn't have to pick a preferred language
					if (event is UnitChangedEvent)  {
						if ((event as UnitChangedEvent).index == 0) {
							resourceManager.localeChain = ["en_US","nl_NL","fr_FR","ro_RO"];
							localeChainAsString = "en_US,nl_NL,fr_FR,ro_RO";
						}
						if ((event as UnitChangedEvent).index == 1) {
							resourceManager.localeChain = ["nl_NL","en_US","fr_FR","ro_RO"];
							localeChainAsString = "nl_NL,en_US,fr_FR,ro_RO";
						}
						if ((event as UnitChangedEvent).index == 2) {
							resourceManager.localeChain = ["fr_FR","en_US","nl_NL","ro_RO"];
							localeChainAsString = "fr_FR,en_US,nl_NL,ro_RO";
						}
						if ((event as UnitChangedEvent).index == 3) {
							resourceManager.localeChain = ["ro_RO","en_US","fr_FR","nl_NL"];
							localeChainAsString = "ro_RO,en_US,fr_FR,nl_NL";
						}
					}
					//Settings gets the value just determined here above, in any case if the database would already be existing, the localechain from database will be taken and the Settings value will again be overwritten
					Settings.getInstance().setSettingWithoutDatabaseUpdate(Settings.SettingsLOCALECHAIN_asString,localeChainAsString);
					
					dispatcher.addEventListener(DatabaseEvent.RESULT_EVENT,onInitResult);
					dispatcher.addEventListener(DatabaseEvent.ERROR_EVENT,onInitError);
					Database.getInstance().init(dispatcher);
				}
				
				function onInitResult(event:Event):void
				{
					dispatcher.removeEventListener(DatabaseEvent.ERROR_EVENT, onInitError);
					dispatcher.removeEventListener(DatabaseEvent.RESULT_EVENT, onInitResult);
					
					//time to check if localechain has a new value retrieved from the database
					var localeChainAsString:String = Settings.getInstance().getSetting(Settings.SettingsLOCALECHAIN_asString);
					var localeChainAsArray:Array = localeChainAsString.split(",");
					resourceManager.localeChain = [];
					for (var j:int = 0;j < localeChainAsArray.length; j++) {
						resourceManager.localeChain.push(localeChainAsArray[j]);
					}
					
					initiateRetrievalOfFoodItemList();
					
					if (firstStartUp) {
						licensePopUp = new AlertPopUp();
						licensePopUp.addEventListener(PopUpEvent.CLOSE, licenseAccepted);
						var textToShow:String = 
							resourceManager.getString('settingsview','version') + 
							resourceManager.getString('settingsview','copyright') +
							resourceManager.getString('settingsview','infoabouttext');
						licensePopUp.show(thisView,textToShow);
					} else {
						Synchronize.getInstance().startSynchronize(false,false);
						showSearchTextBoxHelpText();
					}
					
				}
				
				function licenseAccepted(event: PopUpEvent):void {
					if (licensePopUp != null) {
						PopUpManager.removePopUp(licensePopUp);
						if (licensePopUp.hasEventListener(PopUpEvent.CLOSE)) {
							licensePopUp.removeEventListener(PopUpEvent.CLOSE, okClicked);
						}
					}
					showSearchTextBoxHelpText();
				}
				
				function onInitError(event:Event):void
				{	
					dispatcher.removeEventListener(DatabaseEvent.ERROR_EVENT, onInitError);
					dispatcher.removeEventListener(DatabaseEvent.RESULT_EVENT, onInitResult);
				}
			}
			
			private function showSearchTextBoxHelpText():void {
				if (!(Settings.getInstance().getSetting(Settings.SettingsHelpTextFoodCounterViewSearchText) == 'false')) {
					helpCallOut = new HelpCallOut();
					helpCallOut.helpText = resourceManager.getString('foodcounterview','help_text_searchField');
					helpCallOut.settingId = Settings.SettingsHelpTextFoodCounterViewSearchText;
					helpCallOut.addEventListener(PickerEvent.PICKER_SET,helptext1Removed);
					helpCallOut.open(searchtext,true);
				}
			}
			
			private function helptext1Removed(event:Event):void {
				helpCallOut.removeEventListener(PickerEvent.PICKER_SET,helptext1Removed);
				helpCallOut = new HelpCallOut();
				helpCallOut.helpText = resourceManager.getString('foodcounterview','help_text_searchButton');
				helpCallOut.settingId = Settings.SettingsHelpTextFoodCounterViewSearchButton;
				helpCallOut.addEventListener(PickerEvent.PICKER_SET,helptext2Removed);
				helpCallOut.open(searchButton,true);
			}
			
			private function helptext2Removed(event:Event):void {
				
			}
			
			public function initiateRetrievalOfFoodItemList(event:Event = null):void {
				var dispatcher:EventDispatcher = new EventDispatcher();
				
				dispatcher.addEventListener(DatabaseEvent.RESULT_EVENT,retrieveFoodItemList);
				dispatcher.addEventListener(DatabaseEvent.ERROR_EVENT,onRetrieveListError);
				Database.getInstance().getAllFoodItemDescriptions(dispatcher);
				
				function retrieveFoodItemList(de:DatabaseEvent):void {
					//foodItems = new ArrayCollection();
					dispatcher.removeEventListener(DatabaseEvent.RESULT_EVENT, retrieveFoodItemList);
					dispatcher.removeEventListener(DatabaseEvent.ERROR_EVENT, onRetrieveListError);
					
					ModelLocator.getInstance().foodItemList = new ArrayCollection();
					excelSorting = new ExcelSorting(ModelLocator.getInstance().foodItemList);
					
					if (de.data && de.data is Array) {
						for each (var o:Object in de.data) {
							excelSorting.foodItemList.addItem(new FoodItem(o.description as String, new ArrayCollection(), o.itemid as int));
						}
						excelSorting.foodItemList.refresh();
					} 
				}
				
				function onRetrieveListError(event:Event):void
				{	
					dispatcher.removeEventListener(DatabaseEvent.RESULT_EVENT, retrieveFoodItemList);
					dispatcher.removeEventListener(DatabaseEvent.ERROR_EVENT, onRetrieveListError);
				}
			}
			
			private function selectFoodItem(event:IndexChangeEvent):void {
				MyGATracker.getInstance().trackPageview( "FoodCounterView-itemSelected" );
				
				data = new Object();
				data.searchtext = searchtext.text;//we pass the searchtext to addfooditemview. Addfooditemview will return the searchtext or an empty string when popped
				data.foodItem = ModelLocator.getInstance().foodItemList.getItemAt(event.newIndex);
				navigator.pushView(AddFoodItemView,data);
			}
			
			private function searchTextChanged():void {
				if (searchActive) {
					searchActive = false;
					setAllShownInList(true);
				}
				
				if (searchTextCopy.length > 0) {
					if (searchButton.alpha == 0.25)
						searchButton.alpha = 1;
				} else {
					if (searchButton.alpha == 1)
						searchButton.alpha = 0.25;
				}
				
				ensureIndexIsVisible();
				
			}
			
			private function ensureIndexIsVisible():void {
				fooditemlist.ensureIndexIsVisible(fooditemlist.dataProvider.length - 1);
				fooditemlist.ensureIndexIsVisible(excelSorting.getFirstMatchingItem(searchtext.text));				
			}
			
			private function displayFoodItem(item:Object):String {
				return item.itemDescription;
			}
			
			private function addHandler():void {
				var tempSearchTextCopy:String = searchTextCopy;
				if (navigator.poppedViewReturnedObject != null) {
					if (navigator.poppedViewReturnedObject.object != null) {
						if (navigator.poppedViewReturnedObject.object.searchText != null) {
							searchtext.text = navigator.poppedViewReturnedObject.object.searchText;
							//searchTextCopy now also has the value of searchtext.text as it's bindable
							if (tempSearchTextCopy != searchTextCopy)//means value has been changed within addfooditem, and mostlikely set to empty string
								if (searchTextCopy == "") {
									searchActive = false;
									setAllShownInList(true);
									ModelLocator.getInstance().foodItemList.refresh()
									//searchtextchanged will be called after timer expiry so no need to call it here
								}
							
							timer = new Timer(200, 1);
							timer.addEventListener(TimerEvent.TIMER,timerEnd);
							timer.start();
						}
					}
				}
				
				/* why working with this timer : because when doing the searchtextchanged immediately, then it has no effect,
				* probably because the list is not even drawn when addHandler is called, by applying this delay of 200 ms, searchTextchanged is called after 200 ms, giving the list 200 ms time to be displayed
				**/
				function timerEnd():void {
					ensureIndexIsVisible();
				}
				if (searchTextCopy.length == 0 || searchActive) {
					searchButton.alpha = 0.25;
				} else  {
					searchButton.alpha = 1;
				}  
			}
			
			private function addButtonClicked(event:MouseEvent):void {
				navigator.pushView(OwnItemView,null);
			}
			
			private function cancelClicked(e:MouseEvent = null):void {
				if (!searchActive)
					return;
				
				searchActive = false;
				setAllShownInList(true);
				ModelLocator.getInstance().foodItemList.refresh();//the trigger a redraw
				ensureIndexIsVisible();
				ModelLocator.getInstance().foodItemList.refresh();//the trigger a redraw
			}
			
			private function searchClicked(e:MouseEvent = null):void {
				if (searchActive)
					return;
				if (!searchtext.text != "") {
					return;
				} 
				
				var foundFirstItem:Boolean = false;
				for (var fooditemctr:int = 0;fooditemctr < ModelLocator.getInstance().foodItemList.length;fooditemctr++) {
					if (ExcelSorting.stringAhasStringB((ModelLocator.getInstance().foodItemList.getItemAt(fooditemctr) as FoodItem).itemDescription,searchtext.text)) {
						if (!foundFirstItem)
							setAllShownInList(false);
						foundFirstItem = true;
						(ModelLocator.getInstance().foodItemList.getItemAt(fooditemctr) as FoodItem).shownInList = true;
					}
				}
				if (foundFirstItem) {
					ModelLocator.getInstance().foodItemList.refresh();//the trigger a redraw
					searchActive = true;
					if (!(Settings.getInstance().getSetting(Settings.SettingsHelpTextFoodCounterViewCancelButton) == 'false')) {
						helpCallOut = new HelpCallOut();
						helpCallOut.helpText = resourceManager.getString('foodcounterview','help_text_cancelButton');
						helpCallOut.settingId = Settings.SettingsHelpTextFoodCounterViewCancelButton;
						helpCallOut.open(cancelButton,true)
					}
				} else  {
					notificationPopUp = new Notification();
					notificationPopUp.notificationText = resourceManager.getString('foodcounterview','noitemsfound');
					notificationPopUp.addEventListener(PickerEvent.PICKER_SET, okClicked);
					PopUpManager.addPopUp(notificationPopUp, this, true);
					PopUpManager.centerPopUp(notificationPopUp);
				}
				
				function okClicked(event: PickerEvent):void {
					if (notificationPopUp != null) {
						PopUpManager.removePopUp(notificationPopUp);
						if (notificationPopUp.hasEventListener(PickerEvent.PICKER_SET)) {
							notificationPopUp.removeEventListener(PickerEvent.PICKER_SET, okClicked);
						}
					}
				}
			}
			
			private function setAllShownInList(newValue:Boolean):void  {
				for (var fooditemctr:int = 0;fooditemctr < ModelLocator.getInstance().foodItemList.length;fooditemctr++) {
					(ModelLocator.getInstance().foodItemList.getItemAt(fooditemctr) as FoodItem).shownInList = newValue;
				}
			}
			
		]]>
	</fx:Script>
	
	<s:titleContent>
		<s:TextInput id="searchtext"  text="@{searchTextCopy}" width="100%" change="searchTextChanged()"/>
	</s:titleContent>
	<s:actionContent>
		<s:Button icon="@Embed(source='../assets/ic_menu_close_clear_cancel.png')" id="cancelButton" click="cancelClicked(event)" alpha="{searchActive ? 1:0.25}"/>
		<s:Button icon="@Embed(source='../assets/search48x48.png')" id="searchButton" click="searchClicked(event)"  alpha="{searchActive ? 0.25:1}"/>
		<s:Button icon="@Embed(source='../assets/add48x48.png')" click="addButtonClicked(event)"/>
	</s:actionContent>
	<s:List id="fooditemlist" left="0" right="0" top="0" bottom="0" itemRenderer="myComponents.FoodItemListItemRenderer"
			dataProvider="{ModelLocator.getInstance().foodItemList}" labelFunction="displayFoodItem"
			scrollSnappingMode="leadingEdge">
	</s:List>
</s:View>

